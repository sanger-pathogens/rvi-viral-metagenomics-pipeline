// base config
includeConfig "./rvi_toolbox/nextflow-commons.config"

// Pipeline manifest
manifest {
    name            = 'rvi-pipeline'
    author          = 'Wellcome Sanger Institute - PAM Informatics/GSU-ARD'
    homePage        = 'https://gitlab.internal.sanger.ac.uk/sanger-pathogens/pipelines/rvi-pipeline'
    description     = 'Meta-pipeline for RVI project data analysis including all steps of shotgun metagenomic sample processing'
    mainScript      = 'main.nf'
    nextflowVersion = '>=21.04.0'
    version         = 'v1.3.0'
}

//import subworkflow default configs
includeConfig "./rvi_toolbox/subworkflows/mixed_input.config"
includeConfig "./rvi_toolbox/subworkflows/preprocessing.config"
includeConfig "./rvi_toolbox/subworkflows/subsample.config"
includeConfig "./rvi_toolbox/subworkflows/kraken2bracken.config"
includeConfig "./rvi_toolbox/subworkflows/abundance_estimation.config"
includeConfig "./rvi_toolbox/subworkflows/assemble.config"

params {
    // general pipeline config
    monochrome_logs = false
    results_dir = "./results"
    max_retries = 4 // allows for rare occasions of needing to retry with increased memory
                    // the pipeline is supposed to operate on input reads data of capped size, so excess memory use is expected to remain rare
                    // retries > 2 times is mostly expected to occur for INSTRAIN process, which starts from requesting 4GB mem (16GB at 2nd retry)

    // LSF options
    queue_size = 50
    submit_rate_limit = '50/2min'

    /*
    error handling

    three levels of error for fastq:
    exit_on_error: exit if there are any samples unreadable or below the limit
    only_unreadable: Only exit if there are samples that are unreadable
    ignore: entirely ignore samples that have errors and continue the pipeline
    */
    fastq_error_handling_mode = 'exit_on_error' 


    // Top-level workflow options
    skip_preprocessing = false
    minimum_fastq_reads = 0
    initial_subsample_limit = 10000000 // 10M reads per paired read file; 20M reads total

    // override iRODS Extractor default parameters
    preexisting_fastq_tag = "trimmed_reads"
    split_sep_for_ID_from_fastq = "_1_kneaddata_paired_1.fastq"
    cleanup_intermediate_files_irods_extractor = false
    save_fastqs = false
    save_method = "nested"
    lane_plex_sep = "#"

    // override metagenomic assembly default parameters 
    metaspades_base_mem_gb = 16

    // override Abundance estimation default parameters
    instrain_profile_options = "--min_genome_coverage 0 --min_read_ani 0.9" // RVI default; team162 would have "--database-mode"
    genome_file_abundance_estimation = "/data/pam/software/RVI_DB/viral.1.1.genomic_sorted.fna"
    precomputed_index_abundance_estimation = "/data/pam/software/RVI_DB/viral.1.1.genomic_sorted.bt2"
    cleanup_intermediate_files_abundance_estimation = false
    // stb_file_abundance_estimation = "/data/pam/software/RVI_DB/viral.1.1.genomic.stb"
    stb_file_abundance_estimation = "/data/pam/software/RVI_DB/viral.1.1.genomic_custom.stb"
    custom_taxon_names_abundance_estimation = "/data/pam/software/RVI_DB/handpicked_viral_taxa_short_names_dict.txt"
    
    // override Kraken2Bracken default parameters 
    kraken2bracken_kraken2_db = "/data/pam/software/kraken2/viral_kraken/"
}

process {
    maxRetries = params.max_retries

    withName:KRAKEN2 {
        cpus = { params.kraken2bracken_kraken2_threads }
        memory = { estimate_kraken_mem(params.kraken2bracken_kraken2_db, 1, task) }
    }
}

// Helper functions

/*
Estimates required memory from kraken2 database files, accepts a memory top_up (in GB) to provide head room.
top_up will be increased linearly with each task attempt up to params.max_memory
*/
def estimate_kraken_mem(db, top_up, task) {
    float attempt = task.attempt
    float top_up_float = top_up
    def mem_file = new File("${db}/hash.k2d").size()
    def mem_top_up = (top_up_float * 1024**3) * attempt
    def mem_bytes = mem_file + mem_top_up
    def mem_mb = mem_bytes / (1024**2)
    def valid_mem = "${mem_mb.round()}.MB"
    if (valid_mem.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1) {
        return params.max_memory as nextflow.util.MemoryUnit
    }
    return valid_mem
}
